= Теоријске основе и постојећа решења

Ово поглавље описује теоријске концепте и технологије које су неопходне за разумевање развијеног решења. На почетку су представњени основни принципи контејнеризације, микросервисних архитектура и дистрибуираних система, као и изазови који се јављају у таквим окружењима. Затим су обрађени механизми провере здравља сервиса и основе надгледања система путем метрика. У посебној целини описане су и технологије коришћене у имплементацији решења, као што су _Docker_, _Docker Compose_, _Prometheus_ и _Alertmanager_. Поглавље се завршава прегледом постојећих решења, у ком је приказан _Kubernetes_ _health-check_ механизам који је послужио као референтни модел при дизајну система.

== Теоријски концепти релевантни за разумевање решења

=== Контејнеризација

Контејнеризација представља приступ извршавању апликација у изолованим и преносивим окружењима која се називају контејнери. Они обједињују апликацију и све њене зависности и библиотеке у једну стандардизовану јединицу софтвера, обезбеђујући да се апликација понаша предвидљиво независно од окружења у ком се извршава @containerization. Овај приступ решава проблем различитог понашања софтвера на развојним, тест и продукционим окружењима, чинећи контејнере кључном компонентом савремених дистрибуираних и архитектура y облаку (енгл. _cloud_) @cncf.

За разлику од виртуелних машина, контејнери деле језгро оперативног система домаћина, што резултује минималним оптерећењем ресурса и изузетно брзим покретањем @merkel2014. Ова ефикасност омогућава истовремено извршавање већег броја контејнера на једној машини без значајног утицаја на перформансе. Уз то, контејнери обезбеђују снажну изолацију процеса, мрежних ресурса и система датотека @containerization, чинећи их погодном основом за системе који захтевају стабилно и скалабилно извршавање већег броја независних микросервиса. На слици #link(<fig:containerization>)[1] приказана је поједностављена архитектура контејнеризованог окружења.

#figure(image("../slike/containerization.png", height: 30%),
  caption: [
    Архитектура контејнеризованог окружења @containerization
  ]
)<fig:containerization>

У микросервисним архитектурама, контејнери омогућавају да сваки сервис буде развијан, тестиран и распоређен независно од осталих делова система @richardson2018. Ова изолација олакшава управљање животним циклусом апликација и омогућава тимовима да користе различите технологије и верзије библиотека без конфликата. Међутим, динамична природа контејнеризованих окружења уводи нове изазове у надгледању здравља система, што захтева механизме који могу континуирано да прате доступност и исправност сервиса у реалном времену @burns2018. _Health-check_ системи постају кључни за детекцију проблема попут исцрпљених ресурса, мрежних прекида или неодговарајућих сервиса, обезбеђујући аутоматско опорављање и одржавање високе доступности апликација @kubernetes_probes.

=== Микросервисна архитектура

Микросервисна архитектура представља приступ развоју софтвера у коме је сложена апликација подељена на више малих, независних сервиса, од којих је сваки задужен за јасно дефинисану пословну функционалност @richardson2018. Сваки сервис се развија, тестира и распоређује самостално, најчешће користи сопствену базу података и може бити имплементиран у различитом програмском језику @newman2015. На слици #link(<fig:microservices>)[2] дат је поједностављен приказ микросервисне архитектуре. Иако ова декомпозиција омогућава већу флексибилност и одрживост, она истовремено уводи комплексне ланце позива: један захтев може пролазити кроз више сервиса, а здравље сваке компоненте директно утиче на доступност и перформансе целокупног система @nygard2018.

#figure(image("../slike/microservices.png", height: 30%),
  caption: [
    Основни концепт микросервисне архитектуре @microservices_architecture
  ]
)<fig:microservices>

Микросервисне платформе функционишу у динамичним окружењима у којима се инстанце сервиса континуирано покрећу, заустављају, скалирају и премештају између чворова кластера @fowler2014. Ова динамика, у комбинацији са међусобном завишноћу сервиса, повећава ризик од каскадних отказа, где проблем у једном сервису може довести до деградације рада читавог система @nygard2018.

=== Дистрибуирани системи

Дистрибуирани систем представља скуп независних компоненти које комуницирају преко мреже како би заједно извршавале одређене задатке @tanenbaum2017. Микросервисна архитектура природно гради дистрибуирани систем, јер сваки сервис функционише као засебна компонента која сарађује са другима путем мрежних протокола. За разлику од монолитних апликација где компоненте комуницирају директним позивима функција у оквиру истог процеса, дистрибуирани системи се суочавају са додатним изазовима који произилазе из мрежне комуникације @kleppmann2017.

Мрежна комуникација није поуздана, што доводи до непредвидивог понашања. Посебно су проблематични парцијални откази, где један део система нормално функционише док је други недоступан или ради са лошим перформансама @nygard2018. Овакви откази су теже уочљиви од потпуних, јер није увек јасно да ли сервис не одговара због сопственог проблема, спорог извршавања или застоја на мрежи.

#pagebreak()

Надгледање дистрибуираних система је знатно сложеније од надгледања монолитних апликација @burns2018. Информације о стању система су разложене на десетине независних сервиса, од којих сваки генерише сопствене логове и метрике. Због тога су механизми за праћење здравља система критични за очување стабилности, доступности и благовремено реаговање на отказе сервисa @kubernetes_probes.

=== Системи за проверу здравља

_Health-check_ представља механизам за аутоматско праћење исправности сервиса у дистрибуираним системима. Његова основна сврха је да утврди да ли је сервис у стању да обрађује захтеве и да омогући реаговање у случају неправилног рада @kubernetes_probes. У микросервисним архитектурама, где сваки сервис функционише као независна компонента, континуирана провера здравља је неопходна за очување доступности и спречавање ширења отказа кроз остатак система @newrelic_health.

Разлози за увођење _health-check_ механизама проистичу из природе дистрибуираних система. Сервиси могу постати недоступни услед грешака у извршавању, узајамне блокаде (енгл. _deadlock_), преоптерећења или проблема на мрежи. У таквим ситуацијама процес апликације може и даље постојати, али без могућности да правилно обрађује захтеве. Без аутоматизованих провера, други делови система наставили би да му шаљу саобраћај, што може довести до значајних кашњења или каскадних отказа @newrelic_health.

Да би се ови проблеми открили на време, уводе се различити типови провера здравља који покривају различите фазе животног циклуса сервиса. _Kubernetes_ дефинише три основне категорије провера: _liveness_, _readiness_ и _startup_, од којих свака решава специфичан аспект понашања апликације @kubernetes_probes. На слици #link(<fig:probing_types>)[3] дат је поједностављен приказ основних типова _health-check_ провера.

#figure(image("../slike/probing_types.png", height: 23%),
  caption: [
    Основни типови _health-check_ провера @probing_picture
  ]
)<fig:probing_types>

_Liveness_ _probe_ служи за утврђивање да ли је апликација у исправном стању. Она детектује ситуације у којима процес постоји, али више није функционалан, као што су _deadlock_ или бесконачне петље. Када ова провера више пута узастопно не успе, систем може аутоматски поново покренути контејнер, што побољшава доступност и омогућава брз опоравак од отказа @newrelic_health.

_Readiness probe_ одређује да ли је сервис спреман да прима саобраћај. Она не служи за детекцију кварова, већ за регулисање оптерећења у динамичним условима. Ако провера не успе, сервис се привремено искључује из скупа доступних инстанци, али се сам контејнер не покреће поново @kubernetes_probes. Ово је важно током иницијализације или у условима привременог оптерећења.

_Startup probe_ намењена је апликацијама које имају дужи процес покретања. Она осигурава да се _liveness_ и _readiness_ провере не активирају прерано и не изазову поновно покретање пре него што се апликација у потпуности иницијализује. Ово је посебно значајно за _legacy_ системе или апликације са сложеном фазом иницијализације @kubernetes_probes.

#pagebreak()
Провере здравља изводе се на различите начине, у зависности од природе апликације и доступних интерфејса @newrelic_health:

- _HTTP_ провера: систем шаље _HTTP GET_ захтев на дефинисану путању (нпр. /_health_), при чему се статуси 200–399 сматрају успешним.

- _TCP_ провера: покушава се успостављање _TCP_ конекције на одређени порт сервиса.

- _gRPC_ провера: користи се _gRPC_ _health protocol_ за верификацију исправности сервиса.

Ове технике омогућавају униформан и поуздан начин праћења здравља различитих сервиса у дистрибуираним системима.

=== Метрике и основе надгледања

_Observability_ представља способност система да пружи јасан увид у своје унутрашње стање на основу података које сам генерише током рада. Метрике су квантитативни показатељи који се прикупљају периодично или након одређених догађаја и описују понашање система кроз време. Примери могу бити број успешно обрађених захтева, латенција одговора или број неуспелих провера здравља.

Метрике играју кључну улогу како за администраторе, тако и за аутоматизоване механизме попут распоређивачa (енгл. _scheduler_), компоненти за аутоматско скалирање (енгл. _autoscaler_) и самообављајућих (енгл. _self-healing_) компоненти, које се ослањају на метрике при доношењу одлука у реалном времену @rankovic2024monitoring. Системи за надгледање користе метрике да би детектовали неправилности попут наглог пораста грешака, пада доступности или неуобичајених образаца коришћења ресурса @beyer2016. Алармирање засновано на метрикама омогућава благовремено обавештавање администратора или активирање аутоматских механизама за опоравак, чиме се значајно скраћује време реаговања на проблеме.

_Health-check_ системи који излажу метрике пружају додатну вредност тиме што омогућавају прецизније праћење стања сервиса током времена. Метрике као што су укупан број провера здравља, број неуспелих провера и трајање појединачних провера омогућавају идентификацију трендова и потенцијалних аномалија. Агрегација ових података на нивоу чворова, сервиса или читавих кластера пружа свеобухватан увид у здравље система @rankovic2024monitoring. Излагање метрика у стандардизованим форматима олакшава интеграцију са постојећим алатима за надгледање.

== Технологије коришћене у решењу

_Framework_ је развијен у програмском језику _Go_ @golang, који пружа подршку за конкурентно извршавање (енгл. _goroutines_) и богату стандардну библиотеку за _HTTP_, _TCP_ и _gRPC_ комуникацију. Конфигурација система дефинисана је у _YAML_ формату, чиме смо омогућили једноставан опис сервиса и свих параметара неопходних за провере и откривање проблема. 

За интеграцију са _Docker_ окружењем коришћена је _Docker Engine API_ @docker_api, која омогућава управљање животним циклусом контејнеру укључујући поновно покретање неиспавних инстанци. Метрике о стању сервиса излажу се у _OpenMetrics_ формату @openmetrics_spec компатибилном са _Prometheus_ екосистемом, док _Alertmanager_ @alertmanager прихвата те метрике и шаље обавештења на основу дефинисаних правила. _Docker Compose_ @docker_compose је коришћен за управљањем свим компонентама током локалног развоја и тестирања.

=== _Docker и Docker Compose_

_Docker_ је платформа за контејнеризацију која омогућава паковање апликација заједно са свим њиховим зависностима у изоловане контејнере @containerization. _Docker Engine API_ @docker_api обезбеђује програмски приступ за управљање животним циклусом контејнера, укључујући креирање, покретање, заустављање и брисање. У контексту овог рада, _Docker API_ се користи за аутоматизовано реаговање на неправилности откривене током _health-check_ провера, омогућавајући _framework_-у да поново покрене неисправне контејнере без мануелне интервенције.

_Docker Compose_ је алат за дефинисање и покретање вишеконтејнерских апликација @docker_compose. Помоћу _YAML_ конфигурационе датотеке (_docker-compose.yml_) могуће је описати све сервисе, мреже и дељене директоријумe (енгл. _volumеs_) који чине апликацију, а затим једном командом (_docker-compose up_) покренути целокупно окружење. Ово поједностављује управљање локалним развојним окружењем и тестирање система који се састоји од више компоненти. У овом раду _Docker Compose_ се користи за покретање и управљање _health-check_ _framework_-ом заједно са пратећим сервисима (_Prometheus, Alertmanager_) и тестним апликацијама, омогућавајући брзо подизање и рушење комплетног тестног окружења.

=== _Prometheus_

_Prometheus_ је систем за прикупљање и складиштење метрика, дизајниран специјално за праћење дистрибуираних система и _cloud-native_ апликација @prometheus. Заснива се на _pull_ моделу где _Prometheus_ сервер периодично узима (енгл. _scrape_) метрике са дефинисаних endpoint-а који излажу податке у _OpenMetrics_ формату @openmetrics_spec. Метрике се чувају као временске серије и могу се испитивати помоћу _PromQL_ упитног језика, што омогућава флексибилну анализу и визуелизацију стања система.

У оквиру овог рада, _Prometheus_ прикупља метрике које _health-check_ _framework_ излажe попут број извршених провера, број неуспешних провера и број поновних покретања контејнера, пружајући увид у здравље праћених сервиса током времена.

=== _Alertmanager_

_Alertmanager_ је компонента _Prometheus_ екосистема задужена за обраду и управљање упозорењима (енгл. _alerts_) @alertmanager. Прима аларме које генерише _Prometheus_ на основу дефинисаних правила (енгл. _alerting rules_) и врши њихово груписање, филтрирање и прослеђивање одговарајућим каналима обавештавања. Подржани су бројни начини нотификација, укључујући _email_, _Slack_ и још многе друге интеграције. 

У контексту овог рада, _Alertmanager_ прима аларме засноване на метрикама о поновним покретањима контејнера и аутоматски шаље _email_ обавештења администраторима, што омогућава брзу реакцију на уочене проблеме.

== Постојећа решења

_Kubernetes_ је најкоришћенија платформа за управљање контејнеризованим апликацијама и садржи уграђен систем за аутоматско праћење здравља сервиса @kubernetes_probes. Провере здравља извршава _kubelet_, агент који ради на сваком чвору кластера и брине о томе да _pod_-ови (основна јединица извршавања у _Kubernetes_-у) раде у исправном стању.

_Kubernetes_ подржава више типова провера здравља, а то су  _liveness, readiness_ и _startup probe_ које се дефинишу у конфигурацији _pod_-а и аутоматски извршавају током рада апликације. Сваки _probe_ може користити различите механизме провере, укључујући _HTTP_ захтеве, _TCP_ конекцију, као и _gRPC_ _health protocol_, што омогућава проверу различитих типова сервиса.

Систем на основу резултата ових провера одлучује када треба уклонити pod из саобраћаја, када да га поново укључи или када је потребно извршити поновно покретање контејнера. На овај начин _Kubernetes_ обезбеђује стабилан рад и високу доступност апликација без мануелне интервенције.

Због јасно дефинисане логике и широке примене у индустрији, _Kubernetes health-check_ механизам је у овом раду коришћен као референтни модел приликом дизајна независног _framework_-а за проверу здравља сервиса.